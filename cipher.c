#include <asm/uaccess.h>
#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/crypto.h>
#include <linux/scatterlist.h>
#include <crypto/hash.h>
#include "cipher.h"

#define UDBG printk(KERN_DEFAULT "DBG:%s:%s:%d\n", __FILE__, __func__, __LINE__)
/*
This function is copied from linux crypto.c file. I have renamed and modified it according to the usage of CTR encryption.
Function: crypto_aes_encrypt does encryption for the data specified by the user in the arguments to the size given and 
returns it in designated output buffer. MD5 key is used to encrypt the data securely. The function invokes
Crypto API method crypto_blkcipher_encrypt. 
This function deploys AES encryption in CTR mode thereby avoiding need for padding.
sg_in and sg_out is declared for input and output buffers, tfm object is instantiated and algo type is defined for 
encryption purpose. Then, scatterlist tables are populated and encrypt method is invoked.
*/
static int crypto_aes_encrypt(const void *key, int key_len,
                            void *dst, size_t *dst_len,
                            const void *src, size_t src_len)
{	
        struct scatterlist sg_in[1], sg_out[1]; //scatter list declaration for input and output buffers.
        struct crypto_blkcipher *tfm = crypto_alloc_blkcipher(ENC_ALGO_TYPE, 0, CRYPTO_ALG_ASYNC); //Initialising tfm object
        struct blkcipher_desc desc = { .tfm = tfm, .flags = 0 }; 
        int ret; 
        void *iv; 
        int ivsize; 
        char *aes_iv = "abcdefghijklmnop"; //Initialising IV vector

        if (IS_ERR(tfm))
                return PTR_ERR(tfm);

        //Setting init table for input buffer
        sg_init_table(sg_in, 1);
        sg_set_buf(&sg_in[0], src, src_len);
        
        //Setting init table for output buffer
        sg_init_table(sg_out, 1);
        sg_set_buf(sg_out, dst, *dst_len);
        
        //Setting cipher key for encrypt
        crypto_blkcipher_setkey((void *)tfm, key, key_len);
        iv = crypto_blkcipher_crt(tfm)->iv;
        ivsize = crypto_blkcipher_ivsize(tfm);
        
        memcpy(iv, aes_iv, ivsize);

        //Invoking encrypt method for CTR(AES) encryption.
        ret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in, src_len);
        if (ret < 0) {
                pr_err("crypto_aes_encrypt failed %d\n", ret);                
        }

        crypto_free_blkcipher(tfm);
        return ret;
}


/*
This function is copied from linux crypto.c file. I have renamed and modified it according to the usage of CTR decryption.
Function: crypto_aes_decrypt does decryption for the data specified by the user in the arguments to the size given and 
returns it in designated output buffer. MD5 key is used to encrypt the data securely. The function invokes
Crypto API method crypto_blkcipher_decrypt. 
This function deploys AES decryption in CTR mode thereby avoiding need for padding.
sg_in and sg_out is declared for input and output buffers, tfm object is instantiated and algo type is defined for 
decryption purpose. Then, scatterlist tables are populated and decrypt method is invoked.
*/
static int crypto_aes_decrypt(const void *key, int key_len,
                            void *dst, size_t *dst_len,
                            const void *src, size_t src_len)
{        
        struct scatterlist sg_out[1], sg_in[1]; //scatter list declaration for input and output buffers.
        struct crypto_blkcipher *tfm = crypto_alloc_blkcipher(ENC_ALGO_TYPE, 0, CRYPTO_ALG_ASYNC); //Initialising tfm object
        struct blkcipher_desc desc = { .tfm = tfm, .flags = 0 };
        
        char *aes_iv = "abcdefghijklmnop"; //Initialising IV vector

        void *iv;
        int ivsize;
        int ret;        

        if (IS_ERR(tfm))
                return PTR_ERR(tfm);

        //Setting init table for output buffer
        sg_init_table(sg_out, 1);
        sg_set_buf(&sg_out[0], dst, *dst_len);

        //Setting init table for input buffer
        sg_init_table(sg_in, 1);
        sg_set_buf(sg_in, src, src_len);               

        //Setting cipher key for decrypt
        crypto_blkcipher_setkey((void *)tfm, key, key_len);
        iv = crypto_blkcipher_crt(tfm)->iv;
        ivsize = crypto_blkcipher_ivsize(tfm);
        memcpy(iv, aes_iv, ivsize);

        //Invoking decrypt method for CTR(AES) decryption.
        ret = crypto_blkcipher_decrypt(&desc, sg_out, sg_in, src_len);
        if (ret < 0) {
                pr_err("crypto_aes_decrypt failed %d\n", ret);                
        }
        
        crypto_free_blkcipher(tfm);
        return ret;
}

/*
This function is copied from ecryptfs/crypto.c. 
Function:generate_md5 is renamed and modified according to the usage.
This function takes destination, source and key length. It initialises the desc and hashing type.
And then does init, update and final for crypto_hash. And finally generates the md5 key.
*/
static int generate_md5(char *dst, char *src, int len)                                                            
{
        struct scatterlist sg; //Declaring scatter list.
        struct hash_desc desc = {
                .tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC),  //Allocating tfm object for md5 hash                                          
                .flags = CRYPTO_TFM_REQ_MAY_SLEEP 
        };

        int rc = 0;
        
        //Initialising buffer for md5.
        sg_init_one(&sg, (u8 *)src, len);       
        
        if (IS_ERR(desc.tfm)) 
        {
            rc = PTR_ERR(desc.tfm);        
            goto out;
        }                
        
        //Initializing crypto hash
        rc = crypto_hash_init(&desc);
        if (rc) {
                printk("%s: Error initializing crypto hash; rc = [%d]\n", __func__, rc);
                goto out;
        }

        //Updating crypto hash
        rc = crypto_hash_update(&desc, &sg, len);
        if (rc) {
                printk("%s: Error updating crypto hash; rc = [%d]\n", __func__, rc);
                goto out;
        }

        //Finalizing crypto hash
        rc = crypto_hash_final(&desc, dst);
        if (rc) {
                printk("%s: Error finalizing crypto hash; rc = [%d]\n", __func__, rc);
                goto out;
        }
	
	out:        
        return rc;
}

int writeUpdatedList(sysargs *k_arg, struct list_head **listStart)
{
	int rNo = 0, rc = 0;	
	char *rBuf, *wBuf;
	int wByte=0 ;
	struct file *infile, *outfile;
	struct dentry *infile_dentry, *outfile_dentry;	
	unsigned char *md5_final = NULL;
	mm_segment_t old_fs;	
	struct list_head *iElem = NULL;
	struct list_pattern *cElem = NULL;
	int curVer = k_arg->flags;
	
	//Allocating buffer for md5 key
	md5_final = kmalloc(MD5_KEY_SIZE, GFP_KERNEL);

	if(md5_final == NULL)
	{
		rNo = -ENOMEM;
		goto exit_point;
	}

	memset(md5_final, 0, MD5_KEY_SIZE);

	//Calling MD5 generation function
	rc = generate_md5((char *)md5_final, k_arg->key_buffer, k_arg->keylength);

	if(rc < 0)
	{
		rNo = rc;
		goto md5_final_fail;
	}

	// Allocating memory for read buffer.
	rBuf = kmalloc(PAGE_SIZE, GFP_KERNEL);

	if(rBuf ==  NULL)	
	{
		rNo = -ENOMEM;
		goto md5_final_fail;
	}

	memset(rBuf, 0, PAGE_SIZE);

	//Allocating memory for write buffer.
	wBuf = kmalloc(PAGE_SIZE, GFP_KERNEL);
	if(wBuf == NULL)
	{
		rNo = -ENOMEM;
		goto free_read_buf;
	}

	memset(wBuf, 0, PAGE_SIZE);	

	//Opening file handler for input file.
	infile = filp_open(k_arg->input_file, O_CREAT|O_WRONLY, 0);

	if(!infile || IS_ERR(infile))
	{
		rNo = -ENOENT;
		goto free_write_buf;
	}

	if(!infile->f_op->write)
	{
		rNo = -EROFS;
		goto infile_err;
	}

	//Checking if the input file is a regular file and not a directory.
	if(!S_ISREG(infile->f_path.dentry->d_inode->i_mode))
	{
		rNo = -EBADF;
		goto infile_err;			
	}

	//Opening file handler for output file.
	outfile = filp_open(k_arg->output_file, O_CREAT|O_WRONLY, infile->f_mode);
	
	if(!outfile || IS_ERR(outfile))
	{
		rNo = -ENOENT;
		goto infile_err;
	}

	if(!outfile->f_op->write)
	{
		rNo = -EROFS;
		goto outfile_err;		
	}				
	
	outfile_dentry = outfile->f_path.dentry;
	infile_dentry = infile->f_path.dentry;
	
	//Initializing input and output file offsets to zero for reading and writing.	
	infile->f_pos = 0;
	outfile->f_pos = 0;	

	old_fs = get_fs();
	set_fs(KERNEL_DS);

	wByte = outfile->f_op->write(outfile, md5_final, MD5_KEY_SIZE, &outfile->f_pos);

	if(wByte < 16)
	{
		rNo = -EINVAL;
		goto outfile_err;
	}		
	
	list_for_each(iElem, *listStart)
	{
	    cElem = list_entry(iElem,struct list_pattern,hnode);
	    strcat(rBuf, cElem->pattern);
	    strcat(rBuf, "\n");
	}			

	wByte = strlen(rBuf);

	rc = crypto_aes_encrypt(k_arg->key_buffer, MD5_KEY_SIZE, wBuf, &wByte, rBuf, wByte);	    			    

	if (rc < 0)	
	{
		rNo = rc;
		goto outfile_err;
	}

	wByte = outfile->f_op->write(outfile, wBuf, wByte, &outfile->f_pos);

	vfs_rename(outfile_dentry->d_parent->d_inode, outfile_dentry, infile_dentry->d_parent->d_inode, infile_dentry, NULL, 0);

	rNo = infile->f_path.dentry->d_inode->i_op->setxattr(infile->f_path.dentry,CUR_VERSN,&curVer,sizeof(int),0);
	
	set_fs(old_fs);

	//Exit Point of function.	
	outfile_err:
		filp_close(outfile, NULL);
	infile_err:
		filp_close(infile, NULL);
	free_write_buf:
		kfree(wBuf);
	free_read_buf:
		kfree(rBuf);
	md5_final_fail:
		kfree(md5_final);
	exit_point:
		return rNo;	
}

int validateMount(sysargs *k_arg, struct list_head **listStart)
{

	int rNo = 0, rc = 0, rByte=0, err = 0;	
	char *rBuf, *wBuf, *buf_head;
	struct file *infile;
	unsigned char *md5_final = NULL;
	mm_segment_t old_fs;	
	struct list_pattern *elem = NULL;
	char *token = NULL;

	//Allocating buffer for md5 key
	md5_final = kmalloc(MD5_KEY_SIZE, GFP_KERNEL);

	if(md5_final == NULL)
	{
		rNo = -ENOMEM;
		goto exit_point;
	}

	memset(md5_final, 0, MD5_KEY_SIZE);

	//Calling MD5 generation function
	rc = generate_md5((char *)md5_final, k_arg->key_buffer, k_arg->keylength);

	if(rc < 0)
	{
		rNo = rc;
		goto md5_final_fail;
	}

	// Allocating memory for read buffer.
	rBuf = kmalloc(PAGE_SIZE, GFP_KERNEL);

	if(rBuf ==  NULL)	
	{
		rNo = -ENOMEM;
		goto md5_final_fail;
	}

	memset(rBuf, 0, PAGE_SIZE);

	//Allocating memory for write buffer.
	wBuf = kmalloc(PAGE_SIZE, GFP_KERNEL);
	if(wBuf == NULL)
	{
		rNo = -ENOMEM;
		goto free_read_buf;
	}

	memset(wBuf, 0, PAGE_SIZE);	

	//Opening file handler for input file.
	infile = filp_open(k_arg->input_file, O_RDONLY, 0);

	if(!infile || IS_ERR(infile))
	{
		rNo = -ENOENT;
		goto free_write_buf;
	}

	if(!infile->f_op->read)
	{
		rNo = -EIO;
		goto infile_err;
	}

	//Checking if the input file is a regular file and not a directory.
	if(!S_ISREG(infile->f_path.dentry->d_inode->i_mode))
	{
		rNo = -EBADF;
		goto infile_err;			
	}

	infile->f_pos = 0;

	old_fs = get_fs();
	set_fs(KERNEL_DS);

	rByte = vfs_read(infile, rBuf, MD5_KEY_SIZE, &infile->f_pos);		

	if(rByte < 0)
	{
		rNo = -EIO;
		goto infile_err;
	}

	if (memcmp(rBuf, md5_final, MD5_KEY_SIZE) == 0) //Validating file key and user key.
	{							
		while((rByte = vfs_read(infile, rBuf, PAGE_SIZE, &infile->f_pos)) > 0)
		{								
			//Calling Decrypt method 										
			rc = crypto_aes_decrypt(k_arg->key_buffer, MD5_KEY_SIZE, wBuf, &rByte, rBuf, rByte);

			if(rc < 0)
			{
				rNo = rc;
				goto infile_err;
			}	

			if(k_arg->flags == LIST_ELEMENTS)
			{
				memcpy(k_arg->output_file, wBuf, rByte);
				goto infile_err;
			}

			buf_head = wBuf;
						
			while ((token = strsep(&wBuf,"\n\0")) !=NULL)
			{	
				if (!strcmp(token,""))	
					continue;
		
				elem = kzalloc(sizeof(struct list_pattern), GFP_KERNEL);

				if(!elem)
				{
					err = -ENOMEM;
					goto infile_err;
				}

				elem->pattern = kzalloc(strlen(token), GFP_KERNEL);

				if(!elem->pattern)
				{
					err = -ENOMEM;
					goto infile_err;
				}

				memcpy(elem->pattern, token, strlen(token));
				INIT_LIST_HEAD(&elem->hnode);
				list_add(&(elem->hnode), *listStart);
			}

			wBuf = buf_head;

			if(rc != 0)
			{
				rNo = rc;
				goto infile_err;
			}
				
		}

		if(rByte < 0)
		{
			rNo = -EIO;
			goto infile_err;
		}				
	}
	else //Executes if invalid key is specified.
	{			
		rNo = -EPERM;
		goto infile_err;
	}		

	infile_err:
		filp_close(infile, NULL);
	free_write_buf:
		kfree(wBuf);
	free_read_buf:
		kfree(rBuf);
	md5_final_fail:
		kfree(md5_final);
	exit_point:
		return rNo;	
}
